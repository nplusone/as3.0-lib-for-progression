package be.nplusone {	import jp.progression.casts.*;	import jp.progression.commands.display.*;	import jp.progression.commands.lists.*;	import jp.progression.commands.net.*;	import jp.progression.commands.tweens.*;	import jp.progression.commands.*;	import jp.progression.data.*;	import jp.progression.events.*;	import jp.progression.loader.*;	import jp.progression.*;	import jp.progression.scenes.*;	import jp.progression.commands.managers.Goto;	import flash.system.*;	import flash.display.*;	import flash.events.*;	import flash.text.*	import flash.net.*		import jp.kimulabo.display.*	import stages.*	import buttons.*		/**	 * ...	 * @author Kenji Takasaki	 */	public class ImageScene extends SceneObject {		public var photograph:Photograph;				public var prev:Prev;		public var nxt:Nxt;				private	var n1:Number = 1;		private var n2:Number = 1.5;		private var n3:Number = 0.75;		private var t1:String = "easeOutSine"		private var t2:String = "easeInSine"				/**		 * 新しい ImageScene インスタンスを作成します。		 */		public function ImageScene( name:String = null, initObject:Object = null ) {						// 親クラスを初期化する			super( name, initObject );			// シーンタイトルを設定します。			title = "lookbook | vima";						prev = new Prev();			nxt = new Nxt();					}				/**		 * シーン移動時に目的地がシーンオブジェクト自身もしくは子階層だった場合に、階層が変更された直後に送出されます。		 * このイベント処理の実行中には、ExecutorObject を使用した非同期処理が行えます。		 */		override protected function atSceneLoad():void {			photograph = Photograph(getInstanceById(this.name));			stage.addEventListener(MouseEvent.MOUSE_DOWN, gotoParent );		}				/**		 * シーンオブジェクト自身が目的地だった場合に、到達した瞬間に送出されます。		 * このイベント処理の実行中には、ExecutorObject を使用した非同期処理が行えます。		 */		override protected function atSceneInit():void {			xSetSize();			stage.addEventListener(Event.RESIZE, xSetSize);						var flagS:Boolean = false;						if (this.id == "first") {			prev.visible = false;				nxt.visible = true;			nxt.sceneId = manager.current.next.sceneId;			}else if (this.id == "last") {			prev.visible = true;			nxt.visible = false;			prev.sceneId = manager.current.previous.sceneId;			} else {			nxt.sceneId = manager.current.next.sceneId;			prev.sceneId = manager.current.previous.sceneId;			}						if (manager.current.parent.sceneId.equals(manager.departedSceneId)){			addCommand(			[			new AddChildAt( container, photograph, 18 ),			new AddChildAt( container, prev, 25),			new AddChildAt( container, nxt, 25),			]			);			} else {			var prevscene = getSceneBySceneId(manager.departedSceneId);						addCommand(			[			new RemoveChild( container, prevscene.nxt ),			new RemoveChild( container, prevscene.prev ),			new AddChildAt( container, prev, 25),			new AddChildAt( container, nxt, 25),			],			[			new DoTweener( prevscene.photograph, { alpha:0, time:2, transition:t2 } ),			new AddChildAt( container, photograph, 18 )			],			new RemoveChild( container, prevscene.photograph )			);			}		}				/**		 * シーンオブジェクト自身が出発地だった場合に、移動を開始した瞬間に送出されます。		 * このイベント処理の実行中には、ExecutorObject を使用した非同期処理が行えます。		 */		override protected function atSceneGoto():void {			stage.removeEventListener(MouseEvent.MOUSE_DOWN, gotoParent);			stage.removeEventListener(Event.RESIZE, xSetSize);			if (manager.current.parent.sceneId.equals(manager.destinedSceneId)){			addCommand(			[			new RemoveChild( container, nxt ),			new RemoveChild( container, prev ),			new RemoveChild( container, photograph )			]			);			}		}				/**		 * シーン移動時に目的地がシーンオブジェクト自身もしくは親階層だった場合に、階層が変更される直前に送出されます。		 * このイベント処理の実行中には、ExecutorObject を使用した非同期処理が行えます。		 */		override protected function atSceneUnload():void {					}				private function xSetSize ( event:Event = null ):void		{			var nBASE_WIDTH:Number = 800;			var nBASE_HEIGHT:Number = 1200;						var nScaleY:Number = stage.stageHeight / nBASE_HEIGHT;						photograph.scaleY = nScaleY;			photograph.scaleX = nScaleY;						photograph.x = stage.stageWidth / 2 - (nBASE_WIDTH * nScaleY) / 2;			photograph.y = 0;							prev.x = 36;			prev.y = stage.stageHeight / 2 -17;						nxt.x = stage.stageWidth -49;			nxt.y = stage.stageHeight / 2 -17;					}				public function gotoParent( event:Event = null ):void {			trace(photograph.flagOut);			if (photograph.flagOut && !nxt.hitTestPoint(stage.mouseX, stage.mouseY) && !prev.hitTestPoint(stage.mouseX, stage.mouseY))			{			trace("call")			manager.goto(manager.current.parent.sceneId);			}		}	}}